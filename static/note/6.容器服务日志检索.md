## 背景

在容器化应用中，在没有将容器日志持久化到 ES 中时，针对后端服务的日志文件进行按时间范围检索，需要借助服务自行封装能力查询日志。

原始日志模板(logback.xml): 

```xml
<configuration>

 <property name="PATTERN_DEFAULT" value="%d{yyyy-MM-dd HH:mm:ss.SSS}||${center.name}||${app.name}||${ppAgentid}||%highlight(${LOG_LEVEL_PATTERN:-%p})||%boldYellow(%thread)||%boldGreen(%class.%method:%line)||%X{TestFlag}||%X{ReqClientIP}||%X{ReqType}||%X{ReqBizNum}||%X{ReqTimestamp}||%X{ReqDockerIp}||%X{RepServUnitName}||%X{RepServUnitVersion}||%X{RepDockerIp}||%X{Port}||%X{pinpoint-traceid}||%X{pinpoint-pspanid}||%X{pinpoint-spanid}||%X{X-CTG-Request-Id}||%m%n"/>

</configuration>
```

单个日志文件限制大小为 100M，超过时自动拆分。


## 实现逻辑

定义日志查询上下文类：包含日志目录、日志前缀、日志后缀、开始时间、结束时间等信息，日志文件元数据信息：文件名、文件最后修改时间、文件最后修改时间（毫秒）。

1. 检索日志目录下的日志文件，根据时间范围筛选日志文件（支持 .log, .gz, .0.log, .1.log 等格式）并记录获取文件元数据信息。
2. 遍历日志文件，根据时间范围筛选日志行（支持异常堆栈信息、json格式数据等非标准格式行日志）。


### 检索时间范围内的日志文件

查找指定日期的所有日志文件（支持 .0.log, .1.log, .gz 等）

```java
private List<File> findLogFilesForDate(LocalDate date, LogQueryContext logQueryContext) {
    String dateStr = date.format(FILE_DATE_FORMAT);
    String prefix = logQueryContext.logPrefix + dateStr;

    File logDir = new File(logQueryContext.logDir);
    if (!logDir.exists() || !logDir.isDirectory()) {
        return Collections.emptyList();
    }

    // 匹配：app.2025-09-19.log, app.2025-09-19.0.log, app.2025-09-19.1.log, app.2025-09-19.log.1.gz
    // 预编译正则表达式以提高性能
    String quotedPrefix = Pattern.quote(prefix);
    Pattern pattern1 = Pattern.compile(quotedPrefix + "\\.\\d+\\.log$");
    Pattern pattern2 = Pattern.compile(quotedPrefix + "\\.log\\.\\d+\\.gz$");
    Pattern pattern3 = Pattern.compile(quotedPrefix + "\\.\\d+\\.log\\.gz$");


    File[] files = logDir.listFiles((dir, name) -> {
        if (!name.startsWith(prefix)) {
            return false;
        }
        return name.equals(prefix + ".log") || // 基本日志文件
                pattern1.matcher(name).matches() ||  // .数字.log 格式
                pattern2.matcher(name).matches() ||  // .log.数字.gz 格式
                pattern3.matcher(name).matches();    // .数字.log.gz 格式

    });

    if (files == null || files.length == 0) {
        return Collections.emptyList();
    }

    // 排序：确保按序读取（.log -> .0.log -> .1.log -> .log.1.gz）
    return Arrays.stream(files).sorted((f1, f2) -> {
        String n1 = f1.getName(), n2 = f2.getName();
        // 原始日志文件优先（无序号）
        if (n1.equals(logQueryContext.logPrefix + dateStr + logQueryContext.logSuffix)) {
            return -1;
        }
        if (n2.equals(logQueryContext.logPrefix + dateStr + logQueryContext.logSuffix)) {
            return 1;
        }
        return n1.compareTo(n2); // 字典序排序
    }).collect(Collectors.toList());
}

```


### 获取或创建日志文件的元数据

```java
private synchronized LogFileMetadata getOrCreateMetadata(File file) {
    String filename = file.getName();
    long currentModified = file.lastModified();

    LogFileMetadata meta = metadataCache.get(filename);
    if (meta != null && meta.lastModified == currentModified) {
        return meta; // 未修改，使用缓存
    }

    // 如果元数据不存在或文件已修改，重新读取
    if (meta == null) {
        meta = new LogFileMetadata();
    }
    meta.lastModified = currentModified;
    meta.firstLogTime = null;
    meta.lastLogTime = null;

    try {
        // 读第一行
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(file.getPath()), StandardCharsets.UTF_8)) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (isLikelyNewLogLine(line)) {
                    Matcher matcher = TIMESTAMP_PATTERN.matcher(line);
                    if (matcher.lookingAt()) {
                        meta.firstLogTime = LocalDateTime.parse(matcher.group(1), LOG_TIME_FORMAT);
                        break;
                    }
                }
            }
        }

        // 读最后一行（从文件末尾倒查）
        try (RandomAccessFile raf = new RandomAccessFile(file, "r")) {
            long fileLength = raf.length();
            if (fileLength == 0) {
                metadataCache.put(filename, meta);
                return meta;
            }

            // 从最后 2KB 开始读
            raf.seek(Math.max(0, fileLength - 2048));
            StringBuilder buffer = new StringBuilder();
            String line;
            while ((line = raf.readLine()) != null) {
                buffer.append(new String(line.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8))
                        .append('\n');
            }

            String[] lines = buffer.toString().split("\n");
            for (int i = lines.length - 1; i >= 0; i--) {
                String l = lines[i].trim();
                if (l.isEmpty()) continue;
                if (isLikelyNewLogLine(l)) {
                    Matcher matcher = TIMESTAMP_PATTERN.matcher(l);
                    if (matcher.lookingAt()) {
                        meta.lastLogTime = LocalDateTime.parse(matcher.group(1), LOG_TIME_FORMAT);
                        break;
                    }
                }
            }
        }
    } catch (Exception e) {
        System.err.println("解析文件元数据失败: " + filename + " - " + e.getMessage());
    }

    metadataCache.put(filename, meta);
    return meta;
}
```


### 遍历日志文件

过滤单个日志文件中在时间范围内的日志。

```java
private List<String> filterLogLines(File file, LogQueryContext logQueryContext) throws IOException {
    LocalDateTime startTime = logQueryContext.startTime;
    LocalDateTime endTime = logQueryContext.endTime;
    List<String> result = new ArrayList<>();

    // 利用缓存元数据跳过无需扫描的文件
    LogFileMetadata meta = getOrCreateMetadata(file);
    if (meta.lastLogTime != null && meta.lastLogTime.isBefore(startTime)) {
        return result; // 文件最后日志都早于查询开始时间
    }
    if (meta.firstLogTime != null && meta.firstLogTime.isAfter(endTime)) {
        return result; // 文件第一条日志都晚于结束时间
    }

    StringBuilder currentLog = new StringBuilder(1024);
    LocalDateTime currentLogTime = null;

    // 根据文件扩展名选择输入流
    try (InputStream inputStream = Files.newInputStream(file.toPath());
          InputStream wrappedStream = file.getName()
                  .endsWith(".gz") ? new GZIPInputStream(inputStream) : inputStream;
          BufferedReader reader = new BufferedReader(new InputStreamReader(wrappedStream, StandardCharsets.UTF_8))) {

        String line;
        while ((line = reader.readLine()) != null) {
            // 尝试修复可能乱码的行（GZIP 解压时可能出现编码问题）
            if (line.isEmpty() || !isLikelyValidLine(line)) {
                // 是上一条日志的延续（如堆栈、JSON 多行等）
                if (currentLog.length() > 0) {
                    currentLog.append('\n').append(line);
                }
                continue;
            }

            // 快速判断是否可能是新日志（以 "2025-" 开头）
            if (isLikelyNewLogLine(line)) {
                Matcher matcher = TIMESTAMP_PATTERN.matcher(line);
                if (matcher.lookingAt()) { // 只匹配开头，更快
                    // 保存上一条符合条件的日志
                    if (currentLog.length() > 0 && currentLogTime != null) {
                        if (isInTimeRange(currentLogTime, startTime, endTime)) {
                            result.add(currentLog.toString());
                        }
                        // 提前终止（日志有序时极大提升性能）
                        if (currentLogTime.isAfter(endTime)) {
                            break;
                        }
                    }

                    // 开始新日志
                    currentLog.setLength(0);
                    currentLog.append(line);
                    try {
                        currentLogTime = LocalDateTime.parse(matcher.group(1), LOG_TIME_FORMAT);
                    } catch (Exception e) {
                        currentLogTime = null; // 解析失败，跳过此条
                    }
                    continue;
                }
            }

            // 是上一条日志的延续（如堆栈、JSON 多行等）
            if (currentLog.length() > 0) {
                currentLog.append('\n').append(line);
            }
        }

        // 处理最后一条日志
        if (currentLog.length() > 0 && currentLogTime != null && isInTimeRange(currentLogTime, startTime, endTime)) {
            result.add(currentLog.toString());
        }
    }

    return result;
}
```


## 完整示例代码

```java
public class LogQueryUtil {

    private LogQueryUtil() {
    }

    private static final LogQueryUtil logQueryUtil = new LogQueryUtil();

    public static LogQueryUtil getInstance() {
        return logQueryUtil;
    }

    public static class LogFileMetadata {
        private LocalDateTime firstLogTime;
        private LocalDateTime lastLogTime;
        private long lastModified; // 文件最后修改时间（毫秒）

        public LogFileMetadata() {
        }
    }

    public static class LogQueryContext {
        private String logDir;
        private String logPrefix;
        private String logSuffix;
        private LocalDateTime startTime;
        private LocalDateTime endTime;

        public LogQueryContext() {
        }

        public LogQueryContext(String logDir, String logPrefix, String logSuffix, LocalDateTime startTime, LocalDateTime endTime) {
            this.logDir = logDir;
            this.logPrefix = logPrefix;
            this.logSuffix = logSuffix;
            this.startTime = startTime;
            this.endTime = endTime;
        }
    }

    // 时间格式
    private static final DateTimeFormatter FILE_DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    private static final DateTimeFormatter LOG_TIME_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");

    // 正则：匹配行首的时间戳（精确到毫秒）
    private static final Pattern TIMESTAMP_PATTERN = Pattern.compile("^(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3})");

    // 缓存文件元数据（线程安全）
    private final Map<String, LogFileMetadata> metadataCache = new ConcurrentHashMap<>(64);

    /**
     * 查询指定时间段内的日志（支持跨天）
     */
    public List<String> queryLogs(LogQueryContext logQueryContext) {
        Objects.requireNonNull(logQueryContext.startTime, "startTime 不能为空");
        Objects.requireNonNull(logQueryContext.endTime, "endTime 不能为空");
        Objects.requireNonNull(logQueryContext.logDir, "logDir 不能为空");
        Objects.requireNonNull(logQueryContext.logPrefix, "logPrefix 不能为空");
        Objects.requireNonNull(logQueryContext.logSuffix, "logSuffix 不能为空");

        if (logQueryContext.startTime.isAfter(logQueryContext.endTime)) {
            return Collections.emptyList();
        }

        List<String> result = new ArrayList<>();

        // 计算日期范围
        LocalDate startDay = logQueryContext.startTime.toLocalDate();
        LocalDate endDay = logQueryContext.endTime.toLocalDate();

        LocalDate current = startDay;
        while (!current.isAfter(endDay)) {
            List<File> logFiles = findLogFilesForDate(current, logQueryContext);
            for (File file : logFiles) {
                if (file.exists() && file.isFile() && file.length() > 0) {
                    try {
                        List<String> lines = filterLogLines(file, logQueryContext);
                        result.addAll(lines);
                    } catch (IOException e) {
                        System.err.println("读取日志文件失败: " + file.getName() + " - " + e.getMessage());
                    }
                }
            }
            current = current.plusDays(1);
        }
        return result;
    }

    /**
     * 判断一行是否可能是有效日志（避免乱码行被当作新日志）
     */
    private boolean isLikelyValidLine(String line) {
        if (line.length() < 10) return false;
        // 检查是否有基本可打印字符
        return line.chars().anyMatch(ch -> ch >= 32 && ch <= 126);
    }

    /**
     * 查找指定日期的所有日志文件（支持 .0.log, .1.log, .gz 等）
     */
    private List<File> findLogFilesForDate(LocalDate date, LogQueryContext logQueryContext) {
        String dateStr = date.format(FILE_DATE_FORMAT);
        String prefix = logQueryContext.logPrefix + dateStr;

        File logDir = new File(logQueryContext.logDir);
        if (!logDir.exists() || !logDir.isDirectory()) {
            return Collections.emptyList();
        }

        // 匹配：app.2025-09-19.log, app.2025-09-19.0.log, app.2025-09-19.1.log, app.2025-09-19.log.1.gz
        // 预编译正则表达式以提高性能
        String quotedPrefix = Pattern.quote(prefix);
        Pattern pattern1 = Pattern.compile(quotedPrefix + "\\.\\d+\\.log$");
        Pattern pattern2 = Pattern.compile(quotedPrefix + "\\.log\\.\\d+\\.gz$");
        Pattern pattern3 = Pattern.compile(quotedPrefix + "\\.\\d+\\.log\\.gz$");


        File[] files = logDir.listFiles((dir, name) -> {
            if (!name.startsWith(prefix)) {
                return false;
            }
            return name.equals(prefix + ".log") || // 基本日志文件
                    pattern1.matcher(name).matches() ||  // .数字.log 格式
                    pattern2.matcher(name).matches() ||  // .log.数字.gz 格式
                    pattern3.matcher(name).matches();    // .数字.log.gz 格式

        });

        if (files == null || files.length == 0) {
            return Collections.emptyList();
        }

        // 排序：确保按序读取（.log -> .0.log -> .1.log -> .log.1.gz）
        return Arrays.stream(files).sorted((f1, f2) -> {
            String n1 = f1.getName(), n2 = f2.getName();
            // 原始日志文件优先（无序号）
            if (n1.equals(logQueryContext.logPrefix + dateStr + logQueryContext.logSuffix)) {
                return -1;
            }
            if (n2.equals(logQueryContext.logPrefix + dateStr + logQueryContext.logSuffix)) {
                return 1;
            }
            return n1.compareTo(n2); // 字典序排序
        }).collect(Collectors.toList());
    }

    /**
     * 过滤单个日志文件中在时间范围内的日志
     */
    private List<String> filterLogLines(File file, LogQueryContext logQueryContext) throws IOException {
        LocalDateTime startTime = logQueryContext.startTime;
        LocalDateTime endTime = logQueryContext.endTime;
        List<String> result = new ArrayList<>();

        // 利用缓存元数据跳过无需扫描的文件
        LogFileMetadata meta = getOrCreateMetadata(file);
        if (meta.lastLogTime != null && meta.lastLogTime.isBefore(startTime)) {
            return result; // 文件最后日志都早于查询开始时间
        }
        if (meta.firstLogTime != null && meta.firstLogTime.isAfter(endTime)) {
            return result; // 文件第一条日志都晚于结束时间
        }

        StringBuilder currentLog = new StringBuilder(1024);
        LocalDateTime currentLogTime = null;

        // 根据文件扩展名选择输入流
        try (InputStream inputStream = Files.newInputStream(file.toPath());
             InputStream wrappedStream = file.getName()
                     .endsWith(".gz") ? new GZIPInputStream(inputStream) : inputStream;
             BufferedReader reader = new BufferedReader(new InputStreamReader(wrappedStream, StandardCharsets.UTF_8))) {

            String line;
            while ((line = reader.readLine()) != null) {
                // 尝试修复可能乱码的行（GZIP 解压时可能出现编码问题）
                if (line.isEmpty() || !isLikelyValidLine(line)) {
                    // 是上一条日志的延续（如堆栈、JSON 多行等）
                    if (currentLog.length() > 0) {
                        currentLog.append('\n').append(line);
                    }
                    continue;
                }

                // 快速判断是否可能是新日志（以 "2025-" 开头）
                if (isLikelyNewLogLine(line)) {
                    Matcher matcher = TIMESTAMP_PATTERN.matcher(line);
                    if (matcher.lookingAt()) { // 只匹配开头，更快
                        // 保存上一条符合条件的日志
                        if (currentLog.length() > 0 && currentLogTime != null) {
                            if (isInTimeRange(currentLogTime, startTime, endTime)) {
                                result.add(currentLog.toString());
                            }
                            // 提前终止（日志有序时极大提升性能）
                            if (currentLogTime.isAfter(endTime)) {
                                break;
                            }
                        }

                        // 开始新日志
                        currentLog.setLength(0);
                        currentLog.append(line);
                        try {
                            currentLogTime = LocalDateTime.parse(matcher.group(1), LOG_TIME_FORMAT);
                        } catch (Exception e) {
                            currentLogTime = null; // 解析失败，跳过此条
                        }
                        continue;
                    }
                }

                // 是上一条日志的延续（如堆栈、JSON 多行等）
                if (currentLog.length() > 0) {
                    currentLog.append('\n').append(line);
                }
            }

            // 处理最后一条日志
            if (currentLog.length() > 0 && currentLogTime != null && isInTimeRange(currentLogTime, startTime, endTime)) {
                result.add(currentLog.toString());
            }
        }

        return result;
    }

    /**
     * 判断是否可能是新日志行（以 yyyy- 开头）
     */
    private boolean isLikelyNewLogLine(String line) {
        return line.length() >= 5 && Character.isDigit(line.charAt(0)) && line.charAt(4) == '-';
    }

    /**
     * 判断时间是否在范围内 [start, end]
     */
    private boolean isInTimeRange(LocalDateTime time, LocalDateTime start, LocalDateTime end) {
        return !time.isBefore(start) && !time.isAfter(end);
    }

    /**
     * 获取或创建日志文件的元数据（首尾时间戳）
     */
    private synchronized LogFileMetadata getOrCreateMetadata(File file) {
        String filename = file.getName();
        long currentModified = file.lastModified();

        LogFileMetadata meta = metadataCache.get(filename);
        if (meta != null && meta.lastModified == currentModified) {
            return meta; // 未修改，使用缓存
        }

        // 如果元数据不存在或文件已修改，重新读取
        if (meta == null) {
            meta = new LogFileMetadata();
        }
        meta.lastModified = currentModified;
        meta.firstLogTime = null;
        meta.lastLogTime = null;

        try {
            // 读第一行
            try (BufferedReader reader = Files.newBufferedReader(Paths.get(file.getPath()), StandardCharsets.UTF_8)) {
                String line;
                while ((line = reader.readLine()) != null) {
                    if (isLikelyNewLogLine(line)) {
                        Matcher matcher = TIMESTAMP_PATTERN.matcher(line);
                        if (matcher.lookingAt()) {
                            meta.firstLogTime = LocalDateTime.parse(matcher.group(1), LOG_TIME_FORMAT);
                            break;
                        }
                    }
                }
            }

            // 读最后一行（从文件末尾倒查）
            try (RandomAccessFile raf = new RandomAccessFile(file, "r")) {
                long fileLength = raf.length();
                if (fileLength == 0) {
                    metadataCache.put(filename, meta);
                    return meta;
                }

                // 从最后 2KB 开始读
                raf.seek(Math.max(0, fileLength - 2048));
                StringBuilder buffer = new StringBuilder();
                String line;
                while ((line = raf.readLine()) != null) {
                    buffer.append(new String(line.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8))
                            .append('\n');
                }

                String[] lines = buffer.toString().split("\n");
                for (int i = lines.length - 1; i >= 0; i--) {
                    String l = lines[i].trim();
                    if (l.isEmpty()) continue;
                    if (isLikelyNewLogLine(l)) {
                        Matcher matcher = TIMESTAMP_PATTERN.matcher(l);
                        if (matcher.lookingAt()) {
                            meta.lastLogTime = LocalDateTime.parse(matcher.group(1), LOG_TIME_FORMAT);
                            break;
                        }
                    }
                }
            }
        } catch (Exception e) {
            System.err.println("解析文件元数据失败: " + filename + " - " + e.getMessage());
        }

        metadataCache.put(filename, meta);
        return meta;
    }

    /**
     * 清除缓存（例如日志轮转后调用）
     */
    public void clearCache() {
        metadataCache.clear();
    }

}
```


## 调用示例

```java
public class LoggerQueryTest {

    private static final String LOG_DIR = "./logs/";
    private static final String LOG_PREFIX = "PaasMainApp_all.";
    private static final String LOG_SUFFIX = ".log";

    public static void main(String[] args) {
        // 2025-09-19 14:46:30.724 开始时间
        LocalDateTime start = LocalDateTime.parse("2025-09-19 14:46:30.724", DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));
        // 结束时间
        LocalDateTime end = LocalDateTime.now();

        LogQueryUtil.LogQueryContext logQueryContext = new LogQueryUtil.LogQueryContext(
                LOG_DIR, LOG_PREFIX, LOG_SUFFIX, start, end);

        List<String> logList = LogQueryUtil.getInstance().queryLogs(logQueryContext);
        for (String log : logList) {
            System.out.println(log);
        }
        // 清除缓存的文件元信息（可选）
        // LogQueryUtil.getInstance().clearCache();
    }
}
```

